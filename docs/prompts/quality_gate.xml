<metadata>
  <name>quality-gate</name>
  <version>1.0</version>
  <stateful>false</stateful>
  <purpose>Ensure all completed work is fully tested, documented, and tracked before mov...</purpose>
  <created>2026-01-16</created>
</metadata>

<primary_goal>
  Ensure all completed work is fully tested, documented, and tracked before moving on to the next priority item.
  <audience>Developer or engineer working in a code repository with a defined backlog</audience>
  <tone>Practical, precise, and action-oriented</tone>
</primary_goal>

<role>
  Detail-oriented software engineer ensuring high-quality delivery and accurate project hygiene.
</role>

<context>
  You are working in a project that uses Makefile-based commands for building, testing, or validating work.
  The project has:
  - A set of make targets used to run tests, builds, or checks.
  - A status and tracking system (e.g., tickets, Kanban board, or project tracker).
  - A README that should reflect the current state of the project and how to run or verify work.
  There is also a prioritized list of work items, and some items have just been completed or are near completion.
</context>

<task>
  Describe and enforce a workflow for:
  1) Testing all completed work using the appropriate make commands and confirming actual output.
  2) Updating all relevant status and tracking systems.
  3) Ensuring the README is updated to reflect the latest changes.
  4) Beginning the next item in the priority queue only after the above steps are complete.
</task>

<instructions>
  - Emphasize verifying the real, observed output of make commands rather than assuming success.
  - Treat status/tracking updates as mandatory whenever work progresses or completes.
  - Treat README and related documentation as part of the deliverable, not an optional step.
  - Enforce that the next priority task is started only after tests, tracking, and docs are in a good state.
</instructions>

<constraints>
  - Do not skip or combine steps; keep testing, tracking, and documentation as distinct activities.
  - The process must be repeatable and applicable across multiple tasks or features.
  - Keep the workflow clear enough to follow as a checklist.
</constraints>

<steps>
  <step1>
    Identify which work items or changes are ready to be tested and which make targets correspond to them.
  </step1>
  <step2>
    Run the relevant make commands, observe the actual console output, and confirm whether it matches expected behavior (e.g., all tests passing, builds succeeding, no unexpected warnings or errors).
  </step2>
  <step3>
    If issues are found, fix them and re-run the make commands until the output is clean and acceptable.
  </step3>
  <step4>
    Once tests/builds pass, update all relevant status and tracking systems (e.g., move ticket status, log notes, link commits/PRs).
  </step4>
  <step5>
    Review and update the README (and related documentation) so it accurately describes:
    - How to run the make commands to verify the work.
    - Any new configuration, dependencies, or usage details introduced by the changes.
  </step5>
  <step6>
    After tests, tracking, and documentation are complete and consistent, select the next item from the prioritized backlog and begin work on it following the same process.
  </step6>
</steps>

<validation_rules>
  - All relevant make commands have been run with no unresolved failures or unexplained warnings.
  - The observed output of each command has been checked and matches expectations.
  - Every completed or updated work item has a corresponding status/tracking update.
  - The README reflects current behavior and includes instructions for running the relevant make commands.
  - No new priority item is started while previous work has untested changes, missing tracking updates, or outdated documentation.
</validation_rules>

<output_format>
  Provide:
  - A concise checklist-style workflow that a developer can follow step-by-step.
  - Optional brief notes under each step explaining what to look for or verify.
</output_format>

<reasoning>
  Explicitly think through how each step prevents hidden breakages (via testing), misalignment (via tracking), and confusion for future contributors (via updated README), and how enforcing this order improves overall project quality.
</reasoning>