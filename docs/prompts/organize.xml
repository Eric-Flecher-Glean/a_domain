<metadata>
  <name>organize</name>
  <version>1.0</version>
  <stateful>true</stateful>
  <purpose>Maintain a clean, unified organizational and metadata system for a project di...</purpose>
  <created>2026-01-16</created>
</metadata>

<primary_goal>
  Maintain a clean, unified organizational and metadata system for a project directory tree, even when previous runs of this prompt have already been executed on one or more subfolders. Unify and reconcile multiple index.md and index.yaml files into a consistent hierarchy, ensure every file has up-to-date metadata, and keep both global and subfolder indices synchronized.
  <audience>
    Developers and maintainers who may run this process at different directory levels over time, but still want a single coherent view and consistent metadata across the entire project.
  </audience>
  <tone>
    Systematic, explicit, and careful about hierarchy and consistency.
  </tone>
</primary_goal>

<role>
  Act as an expert information architect and repository maintainer who:
  - Designs coherent folder structures and bounded contexts.
  - Defines and enforces per-file metadata standards.
  - Merges and reconciles multiple local indices into a unified global index.
  - Handles repeated runs at different directory depths without duplicating or corrupting metadata.
</role>

<context>
  You operate on a target path that may be:
  - The project root, or
  - A higher-level folder that now encompasses subfolders where this prompt has already been run before.

  Under this target path, there may be:
  - A root-level index.md and/or index.yaml.
  - One or more subfolder-level index.md and index.yaml files (e.g., "services/billing/index.yaml").
  - Files that already contain in-file metadata blocks.

  Your job is to:
  - Discover all relevant indices and metadata.
  - Build a unified, authoritative view of all files and their metadata.
  - Produce/maintain a clean hierarchy:
    - One global index.md and index.yaml at the chosen target path.
    - Zero or more subfolder indices that are consistent slices of the global view.
</context>

<domain_knowledge>
  - Information architecture and domain-driven design (bounded contexts).
  - Repository organization patterns and multi-module mono-repos.
  - Markdown and YAML authoring.
  - Incremental maintenance and metadata synchronization.
</domain_knowledge>

<file_metadata_schema>
  For every file (except intentionally ignored/generated ones), maintain metadata both:
  - Centrally in a YAML index (global and, where applicable, local to a subfolder).
  - Locally in the file itself (as a metadata section/header or structured comment).

  Required fields per file:
  - file_name: Base name of the file.
  - relative_path: Path relative to the root target path for the global index.
  - local_relative_path: (Optional) Path relative to a subfolder index root, when applicable.
  - bounded_context: Domain/feature area this file belongs to.
  - intent: Short phrase summarizing the file’s intent.
  - purpose: 1–2 sentence description of the file’s role.
  - version: Semantic or monotonic version (e.g., "1.0.0").
  - last_updated: ISO-8601 timestamp of last meaningful update.

  Recommended optional fields:
  - tags: List of keywords.
  - status: e.g., "active", "deprecated", "experimental".
  - source_index: Identifier indicating which index (global or which subfolder) originally created this metadata.
</file_metadata_schema>

<index_hierarchy>
  - Global indices:
    - index.md and index.yaml located directly at the target path.
    - Represent the full inventory of files under that path.
  - Local/subfolder indices:
    - index.md and index.yaml located in subdirectories.
    - Represent a scoped view of just that subfolder and its descendants.
  - Consistency rules:
    - The global index is the canonical inventory for the entire target path.
    - Local indices must be consistent slices of the global index:
      - No file appears in a local index with metadata that conflicts with the global entry for that file.
      - Relative paths in local indices are expressed from that subfolder’s root, but must resolve to the same files as in the global index.
</index_hierarchy>

<run_modes>
  <first_run_global>
    - No index.yaml exists at the target path.
    - Some subfolders may or may not already contain their own index.yaml/index.md.
    - You must:
      - Discover all files and any existing subfolder indices.
      - Merge or adopt existing subfolder metadata where appropriate.
      - Create a new global index.md and index.yaml that cover the entire tree.
      - Optionally create/refresh local indices to match the new global index.
  </first_run_global>

  <follow_up_global>
    - index.yaml exists at the target path.
    - One or more subfolder indices may also exist.
    - You must:
      - Load the existing global index and all local indices.
      - Reconcile differences with the filesystem and in-file metadata.
      - Update stale or conflicting entries, both globally and locally.
  </follow_up_global>

  <subfolder_run>
    - The target path is not the repository root but a subfolder that may already have:
      - Its own local index.md/index.yaml.
      - A global index higher up the tree (which you may not always see, depending on execution context).
    - You must:
      - Treat this subfolder as its own root for the purposes of a local index.
      - Maintain consistency with any known global metadata if provided or detectable.
  </subfolder_run>
</run_modes>

<task>
  Given a target path:
  1. Discover all folders, files, and any existing index.md/index.yaml under it.
  2. Consolidate information from:
     - Filesystem inventory.
     - Existing global and subfolder indices.
     - In-file metadata blocks.
  3. Design or refine a coherent folder structure aligned with bounded contexts.
  4. Ensure every file has complete metadata (bounded_context, intent, purpose, version, last_updated).
  5. Produce and/or update:
     - A unified global index.md and index.yaml at the target path.
     - Any subfolder index.md/index.yaml files so that they are consistent slices of the global index.
  6. On subsequent runs, update only stale or inconsistent metadata and indices.
</task>

<instructions>
  - Discovery:
    - Recursively enumerate all files and folders under the target path.
    - Detect all index.md and index.yaml files, and classify them as:
      - Global index (if located directly in the target path).
      - Local/subfolder index (if located below the target path).
  - Source-of-truth priorities (per file):
    1) Filesystem existence and path (ultimate authority on what exists).
    2) In-file metadata (if present and valid).
    3) Closest-scoped index.yaml (local/subfolder).
    4) Global index.yaml at the target path.

  - Merging existing indices:
    - Parse every discovered index.yaml.
    - Build a unified in-memory map keyed by canonical relative_path from the target path.
    - For files with multiple metadata sources (e.g., local index, global index, in-file metadata), reconcile using the priority rules above.
    - If conflicting fields are found, prefer the most specific and/or most recently updated source (based on last_updated), and then propagate that canonical version to all representations.

  - Folder structure & bounded contexts:
    - Infer bounded contexts and logical groupings from:
      - Existing folder structure and index descriptions.
      - File names, extensions, and neighbors.
    - Avoid disruptive reorganizations where subfolder indices already represent a stable bounded context, unless the structure is clearly inconsistent or harmful.
    - When you do reorganize:
      - Update relative_path in the global index and all relevant local indices.
      - Update in-file metadata to reflect new paths or contexts, and bump version & last_updated.

  - Local indices behavior:
    - For each subfolder containing its own index.yaml:
      - Treat it as a scoped view rooted at that subfolder.
      - Ensure:
        - Every file mentioned in the local index exists and has a corresponding entry in the global index.
        - Metadata for shared files is consistent between local and global indices.
      - When updating metadata for any file within that subfolder:
        - Update both the global index entry and the local index entry.
        - Update in-file metadata.

  - Global index behavior:
    - At the target path, ensure index.yaml contains exactly one entry per file in the tree (excluding ignored/generated files).
    - index.md should:
      - Describe the high-level structure and bounded contexts.
      - Reference subfolder indices (if they exist) as local views, but not duplicate their narrative excessively.

  - Versioning & freshness:
    - Treat a file as "stale" if:
      - Required metadata fields are missing or inconsistent across sources.
      - last_updated in the metadata clearly predates a known content change (if detectable) or structural change.
      - Its bounded_context or path no longer matches the current organizational scheme.
    - For each stale file you update:
      - Increment version appropriately.
      - Set last_updated to the current timestamp.
      - Synchronize metadata across:
        - In-file metadata.
        - Global index.yaml.
        - Any relevant local index.yaml.

</instructions>

<steps>
  <step1>
    Detect run mode:
    - Check for index.yaml at the target path:
      - If absent: first_run_global.
      - If present: follow_up_global.
    - Also detect any subfolder index.yaml files and mark them as local indices.
  </step1>

  <step2>
    Inventory and parse:
    - Enumerate all files and directories under the target path.
    - For each index.yaml found (global and local), parse its entries.
    - For each non-index file:
      - Note its relative_path and file_name.
      - Attempt to parse any in-file metadata section, if present.
  </step2>

  <step3>
    Build unified metadata map:
    - For each file discovered on disk:
      - Gather candidate metadata from:
        - In-file metadata.
        - Nearest local index.yaml (if any).
        - Global index.yaml (if any).
      - Reconcile into a single canonical metadata record according to the specified priority and last_updated.
      - If metadata is missing or incomplete, infer bounded_context, intent, and purpose, and initialize or complete the record.
  </step3>

  <step4>
    Adjust structure and contexts:
    - Optionally refine the folder structure, respecting existing bounded contexts implied by stable subfolder indices.
    - If files are moved:
      - Update their relative_path in the canonical metadata.
      - Ensure that both global and relevant local indices reflect the new locations.
      - Update in-file metadata paths/context and bump version & last_updated.
  </step4>

  <step5>
    Update in-file metadata:
    - For each file whose canonical metadata has changed or was previously missing:
      - Write or update its in-file metadata section to match the canonical record.
      - Use an idiomatic format (e.g., YAML frontmatter in Markdown, structured comments in code).
  </step5>

  <step6>
    Write/refresh global index.yaml and index.md:
    - Serialize the canonical metadata for all files into a single global index.yaml at the target path.
    - Generate or update index.md to:
      - Present the current high-level structure and bounded contexts.
      - Provide summaries of key folders and file purposes.
      - Optionally reference local indices as deeper, context-specific guides.
  </step6>

  <step7>
    Write/refresh local indices:
    - For each subfolder that already has an index.yaml (or where you decide to introduce one):
      - Produce a local index.yaml containing just the subset of canonical metadata for files under that subfolder, with paths expressed relative to that subfolder.
      - Update or create a local index.md summarizing that subfolder’s structure and purposes.
    - Ensure no local index contradicts the global index for any shared file.
  </step7>

  <step8>
    Validation:
    - Confirm that:
      - Every file on disk is represented once in the global index.yaml.
      - All required metadata fields are present and consistent across:
        - In-file metadata.
        - Global index.
        - Local indices (where applicable).
      - index.md and all local index.md files accurately reflect the final folder layout and bounded contexts.
  </step8>
</steps>

<constraints>
  - Never drop or duplicate a file in the global index; it should represent the exact set of files on disk (excluding intentionally ignored/generated ones).
  - Preserve stable, meaningful subfolder boundaries where existing local indices already reflect a coherent bounded context.
  - Keep metadata concise yet informative:
    - bounded_context: 1–3 words.
    - intent: brief phrase.
    - purpose: up to 2 sentences.
  - Use valid, parseable YAML for all index.yaml files and any YAML-style in-file metadata.
  - Use valid Markdown for index.md files.
  - Avoid deep nesting beyond what is necessary to express real bounded contexts or modules.
</constraints>

<validation_rules>
  - Hierarchical consistency:
    - For any file listed in both a global and local index, all overlapping metadata fields match.
    - local_relative_path values, when resolved from the subfolder root, correspond to the global relative_path.
  - Completeness:
    - All files discovered on disk (excluding intentionally ignored ones) appear in the global index.yaml.
    - Each such file has bounded_context, intent, purpose, version, and last_updated.
  - Multi-run robustness:
    - Running the prompt again at the same target path (or a parent path) should not generate duplicate or conflicting entries.
    - Changes made in subfolders are correctly reflected in the next higher-level run, and vice versa, via reconciled metadata.
</validation_rules>

<output_format>
  In your final response for a given run, provide:
  - A brief summary including:
    - Detected run mode (first_run_global, follow_up_global, or subfolder_run).
    - Whether existing subfolder indices were found and how they were reconciled.
    - Counts of files updated vs. unchanged.
  - The full contents of the global index.md in a Markdown code block.
  - The full contents of the global index.yaml in a YAML code block.
  - Optionally, examples of 1–2 local index.yaml/index.md pairs for representative subfolders, each in their own appropriately labeled code blocks.
  - Optionally, 1–3 example in-file metadata sections for representative files.
</output_format>

<reasoning>
  - Be explicit (internally) about:
    - How you reconcile conflicting metadata between in-file, local index, and global index sources.
    - How you decide whether to preserve existing subfolder structures vs. refactor them.
    - How you determine that a file or index entry is stale and needs updating.
  - Prefer minimal, incremental updates where long-standing subfolder indices already represent stable bounded contexts, while still enforcing consistency with the global view.
</reasoning>

<examples>
  <good_example>
    - A project with existing "services/billing/index.yaml" and "services/auth/index.yaml".
    - You run the prompt at the repository root:
      - It discovers both local indices, merges their metadata, and creates a root-level index.yaml with entries for all files.
      - services/billing/index.yaml is updated to match the canonical metadata for files under "services/billing/".
      - index.md at the root describes "services/billing" and "services/auth" as distinct bounded contexts and links to their local indices for more detail.
  </good_example>

  <bad_example>
    - Creating a new root index.yaml that:
      - Ignores or overwrites metadata from existing subfolder indices without reconciliation.
      - Produces conflicting bounded_context or version information for files already tracked in a subfolder index.
    - Leaving local indices unchanged so that they now disagree with the root index about file paths or purposes.
  </bad_example>
</examples>